190307

그래픽스 : 컴퓨터로 그리는거

offline 그래픽스
	영화그래픽스 

interactive 그래픽스
	게임, 실시간반응
	반응빨라야됨

사진에서 사람 누키 따내기
	컨볼루셔널 뉴럴 네트워크가 함

사물을 AI가 인식해서 그 사물만 초점 맞춰서 DSLR효과

자율주행자동차 훈련영상 그래픽스로 만들어냄
학습도구를 만들 때 컴퓨터 그래픽스 많이 사용됨

라이브러리 사용해서 입체 따낼수있음

글로벌 vs 로컬 일루미네이션
	일루미네이션: 광원이 물체를 비추면 그 물체도 광원이 됨 >> 실제적 >> 글로벌 >> 트리를 만들어야 하는데 어려움.
	오픈gl은 로컬 일루미네이션만 서포트함
	글로벌 일루미네이션 속임수를 통해 구현. 
		texture baking. 미리 계산해놓은걸 붙여넣기
		텍스쳐

글로벌 일루미네이션
	그림자가 되는지는 빛이 다 닿고 최종적으로 결정되는건데 opengl에서는 로컬일루미네이션은 사실상 불가. 속임수를 통해 그림자 넣음
	
로컬 일루미네이션
	반사되는 광원 고려X
	
오픈gl 2점대 커버할것임

190312

컴퓨터 그래픽스 시스템
프레임버퍼 = 그림을 그리는 물리적인 캔버스 = 그래픽카드?
프레임버퍼를 여러번 보여줌

60년대
배불뚝이 모니터는 한점한점 빛을 쏴줌. 느렸음
와이어프레임 그래픽스 = 선을 모니터에 쏴줌
벡터 그래픽스

70년대
래스터그래픽스 = 픽셀들의 array. 내부도 칠할 수 있음

80년대
리얼리즘

90년대
opengl api 풀림

그래픽스 : 이미지포메이션. 알고리즘 자료구조를 통해
인간의 경험이 녹아있음
뷰어, 오브젝트, 빛, 속성(재질 등)

실제 vs 그래픽스
모델링 by 폴리곤(다각형)
폴리곤 이어붙여서

뷰어
perspective vs orthographic
perspective = 투사적으로 본다. 원근 있는거
오쏘그래픽 = 직각

빛
일자로 가는지, 스팟라이트, 포인트라이트

어트리뷰트
재질 = 텍스쳐

그래픽카드는 네가지 절차를 통해 화면을 구성. 
이러한 절차를 파이프라인이라고 함


래스터라이저 = 픽셀을 그림
프레그먼트 쉐이더 = 저 픽셀의 컬러값이 뭔지

190314

실세계와 컴퓨터 그래픽의 다른 점
컴퓨터는 알고리즘으로 구현해야 함
실시간으로 되냐에 따라 리얼타임인지 아닌지
perspective vs orthographic

가상의 카메라 모델
인간은 상이 렌즈 뒤에 맺힘 그래서 상이 거꾸로 맺힘
근데 뇌에 전달할때 뒤집어서 전달함. 
이것을 그대로 구현한게 초기의 카메라
복잡하니까 상이 앞에 맺히도록 구현하게 됨. 그러면 거꾸로 맺히지 않음
투사 = 프로젝션. projection
센터 오브 프로젝션 = 가상카메라의 위치
프로젝션 = 맺히는 것
맺힌 것 = 이미지
이미지플레인이 앞에 있든 뒤에 있든 상관 없음. 의미 없음

본다는 것 - 선형 투사 기법 == perspective?


진짜처럼 그리는 법을 르네상스 시대에 알아냄
perspective 자연스러운데 복잡
오소그래픽 자연스럽지 않지만 계산 쉬움
카메라에 보이지 않는 부분 클리핑됐다고 함
너무 가까이 있는 물체는 보지 않겠다고 설정함
위아래왼오 앞 뒤 클리핑플레인

extrinsic parameter : 방향(위도, 경도, 회전) , 위치(xyz)
	6개 설정하면 됨

glulookat 파라미터 실제론 9개임
	eyex, eyey, eyez  >> 위치
	center x, y, z  >> 
	updirection x, y, z 
	
입력에서 들어온 업방향 을 안쓰고 수정해서 사용함. 어떻게?
	-z 방향을 알 수 있음. 업방향을 대충만 줘도 한 평면을 알 수 있음.
	이를 외적하면 +x방향을 알 수 있음
	이를 통해 완벽한 y방향을 알 수 있음.

	시스템에서 자동으로 업데이트하는 알고리즘임
	숙제로 나올 것

세상을 설명하는 좌표계, 나만의 시선 좌표계 따로
여기서 파라미터 값은 모두 세상의 좌표계의 좌표 값임
eye, center는 정확하게 줄수 있지만 up좌표는 어려움. 이를 시스템이 조정해줌

190319

센터오브프로젝션 = 렌즈
클리핑플레인 앞뒤에도 있음

끄덕 도리 갸웃 직관적이지 않음
회전 순서에따라 결과 다름

glulookat 파라미터 9개
카메라(센터오브프로젝션)의 좌표, 
보려는 방향의 센터xyz (즉 z좌표의 깊이는 관계없음), 
업xyz(y방향 90도 위)

>>extrinsic 파라미터

카메라의 위치 방향을 결정했다고 영상이 결정되는것은 아님 >> 줌인 줌아웃 렌즈 바꾸기 등
>> intrinsic 파라미터

각도 넓히기 >> 줌아웃, 각도 좁히기 >> 줌아웃
그래픽스에서는 위 아래의 각을 잼

오소에서는 담을 영역을 좁히면 줌인, 넓히면 줌아웃

물체에 대해서

정점데이터
연결한 face 데이터
두가지

대부분의 정보는 버텍스에 몰려있음 = 버텍스 어트리뷰트

반시계방향으로 버텍스 순서 줘야함

폴리곤 수프 (폴리곤마다) : 직관적, 메모리낭비

버텍스리스트 & 폴리곤 : 인덱스를 줌

버텍스로 폴리곤을 그릴때 더이상 안보낸다는 정보도 보내줘야함 >> 그래서 느림
>> 무조건 삼각형을 그리기로 함 

190321

네트워크 구조
gpu에도 cpu처럼 계산, 메모리 저장 가능
opengl에서는 반드시 gpu를 통해서만 그리기 가능
cpu는 그리기 위해 gpu로 보냄
cpu만 메인메모리 저장 가능.
그릴때마다 gpu로 전송할수도 있고 gpu메모리에 저장해서 그릴수도 있음
매번 보내기 == 버텍스 어레이
gpu 저장 == 버텍스 버퍼 오브젝트
(000 오브젝트 == gpu 메모리에서 뭔가 만드는 것)

버텍스 버퍼 오브젝트 절차
gpu 메모리에 버퍼 오브젝트를 잡음
버퍼 오브젝트를 바인드 (oop적으로 하기 위해. 객체지정과 유사)
스토리지 요구
등등 절차를 거침

gpu쪽에 메모리 세팅
세팅된 것으로 그리기
이렇게 크게 두 부분으로 되어있음

실습
카메라를 만들어주지 않음
기본적으로 오소그래픽이 디폴트
범위가 1인게 디폴트


