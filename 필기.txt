190307

그래픽스 : 컴퓨터로 그리는거

offline 그래픽스
	영화그래픽스 

interactive 그래픽스
	게임, 실시간반응
	반응빨라야됨

사진에서 사람 누키 따내기
	컨볼루셔널 뉴럴 네트워크가 함

사물을 AI가 인식해서 그 사물만 초점 맞춰서 DSLR효과

자율주행자동차 훈련영상 그래픽스로 만들어냄
학습도구를 만들 때 컴퓨터 그래픽스 많이 사용됨

라이브러리 사용해서 입체 따낼수있음

글로벌 vs 로컬 일루미네이션
	일루미네이션: 광원이 물체를 비추면 그 물체도 광원이 됨 >> 실제적 >> 글로벌 >> 트리를 만들어야 하는데 어려움.
	오픈gl은 로컬 일루미네이션만 서포트함
	글로벌 일루미네이션 속임수를 통해 구현. 
		texture baking. 미리 계산해놓은걸 붙여넣기
		텍스쳐

글로벌 일루미네이션
	그림자가 되는지는 빛이 다 닿고 최종적으로 결정되는건데 opengl에서는 로컬일루미네이션은 사실상 불가. 속임수를 통해 그림자 넣음
	
로컬 일루미네이션
	반사되는 광원 고려X
	
오픈gl 2점대 커버할것임

190312

컴퓨터 그래픽스 시스템
프레임버퍼 = 그림을 그리는 물리적인 캔버스 = 그래픽카드?
프레임버퍼를 여러번 보여줌

60년대
배불뚝이 모니터는 한점한점 빛을 쏴줌. 느렸음
와이어프레임 그래픽스 = 선을 모니터에 쏴줌
벡터 그래픽스

70년대
래스터그래픽스 = 픽셀들의 array. 내부도 칠할 수 있음

80년대
리얼리즘

90년대
opengl api 풀림

그래픽스 : 이미지포메이션. 알고리즘 자료구조를 통해
인간의 경험이 녹아있음
뷰어, 오브젝트, 빛, 속성(재질 등)

실제 vs 그래픽스
모델링 by 폴리곤(다각형)
폴리곤 이어붙여서

뷰어
perspective vs orthographic
perspective = 투사적으로 본다. 원근 있는거
오쏘그래픽 = 직각

빛
일자로 가는지, 스팟라이트, 포인트라이트

어트리뷰트
재질 = 텍스쳐

그래픽카드는 네가지 절차를 통해 화면을 구성. 
이러한 절차를 파이프라인이라고 함


래스터라이저 = 픽셀을 그림
프레그먼트 쉐이더 = 저 픽셀의 컬러값이 뭔지

190314

실세계와 컴퓨터 그래픽의 다른 점
컴퓨터는 알고리즘으로 구현해야 함
실시간으로 되냐에 따라 리얼타임인지 아닌지
perspective vs orthographic

가상의 카메라 모델
인간은 상이 렌즈 뒤에 맺힘 그래서 상이 거꾸로 맺힘
근데 뇌에 전달할때 뒤집어서 전달함. 
이것을 그대로 구현한게 초기의 카메라
복잡하니까 상이 앞에 맺히도록 구현하게 됨. 그러면 거꾸로 맺히지 않음
투사 = 프로젝션. projection
센터 오브 프로젝션 = 가상카메라의 위치
프로젝션 = 맺히는 것
맺힌 것 = 이미지
이미지플레인이 앞에 있든 뒤에 있든 상관 없음. 의미 없음

본다는 것 - 선형 투사 기법 == perspective?


진짜처럼 그리는 법을 르네상스 시대에 알아냄
perspective 자연스러운데 복잡
오소그래픽 자연스럽지 않지만 계산 쉬움
카메라에 보이지 않는 부분 클리핑됐다고 함
너무 가까이 있는 물체는 보지 않겠다고 설정함
위아래왼오 앞 뒤 클리핑플레인

extrinsic parameter : 방향(위도, 경도, 회전) , 위치(xyz)
	6개 설정하면 됨

glulookat 파라미터 실제론 9개임
	eyex, eyey, eyez  >> 위치
	center x, y, z  >> 
	updirection x, y, z 
	
입력에서 들어온 업방향 을 안쓰고 수정해서 사용함. 어떻게?
	-z 방향을 알 수 있음. 업방향을 대충만 줘도 한 평면을 알 수 있음.
	이를 외적하면 +x방향을 알 수 있음
	이를 통해 완벽한 y방향을 알 수 있음.

	시스템에서 자동으로 업데이트하는 알고리즘임
	숙제로 나올 것

세상을 설명하는 좌표계, 나만의 시선 좌표계 따로
여기서 파라미터 값은 모두 세상의 좌표계의 좌표 값임
eye, center는 정확하게 줄수 있지만 up좌표는 어려움. 이를 시스템이 조정해줌

190319

센터오브프로젝션 = 렌즈
클리핑플레인 앞뒤에도 있음

끄덕 도리 갸웃 직관적이지 않음
회전 순서에따라 결과 다름

glulookat 파라미터 9개
카메라(센터오브프로젝션)의 좌표, 
보려는 방향의 센터xyz (즉 z좌표의 깊이는 관계없음), 
업xyz(y방향 90도 위)

>>extrinsic 파라미터

카메라의 위치 방향을 결정했다고 영상이 결정되는것은 아님 >> 줌인 줌아웃 렌즈 바꾸기 등
>> intrinsic 파라미터

각도 넓히기 >> 줌아웃, 각도 좁히기 >> 줌아웃
그래픽스에서는 위 아래의 각을 잼

오소에서는 담을 영역을 좁히면 줌인, 넓히면 줌아웃

물체에 대해서

정점데이터
연결한 face 데이터
두가지

대부분의 정보는 버텍스에 몰려있음 = 버텍스 어트리뷰트

반시계방향으로 버텍스 순서 줘야함

폴리곤 수프 (폴리곤마다) : 직관적, 메모리낭비

버텍스리스트 & 폴리곤 : 인덱스를 줌

버텍스로 폴리곤을 그릴때 더이상 안보낸다는 정보도 보내줘야함 >> 그래서 느림
>> 무조건 삼각형을 그리기로 함 

190321

네트워크 구조
gpu에도 cpu처럼 계산, 메모리 저장 가능
opengl에서는 반드시 gpu를 통해서만 그리기 가능
cpu는 그리기 위해 gpu로 보냄
cpu만 메인메모리 저장 가능.
그릴때마다 gpu로 전송할수도 있고 gpu메모리에 저장해서 그릴수도 있음
매번 보내기 == 버텍스 어레이
gpu 저장 == 버텍스 버퍼 오브젝트
(000 오브젝트 == gpu 메모리에서 뭔가 만드는 것)

버텍스 버퍼 오브젝트 절차
gpu 메모리에 버퍼 오브젝트를 잡음
버퍼 오브젝트를 바인드 (oop적으로 하기 위해. 객체지정과 유사)
스토리지 요구
등등 절차를 거침

gpu쪽에 메모리 세팅
세팅된 것으로 그리기
이렇게 크게 두 부분으로 되어있음

실습
카메라를 만들어주지 않음
기본적으로 오소그래픽이 디폴트
범위가 1인게 디폴트


190326

올해는 버텍스버퍼만 실습함
정육면체는 삼각형 열두번 그림
반복적으로 그리는 방법 >> glDrawArrays() 함수
인덱스를 이용하는 방법 >> glDrawElements() 함수

카메라 모델을 합쳐서 이해해야함 >> transformations = 변환
물체를 이동, 회전, 확대축소

homogeneous coordinate
포인트와 벡터는 다른 개념
포인트 마지막 1
벡터는 마지막 0
벡터는 평행이동해도 같은 벡터임(위치x)

affine space
스칼라벡터포인트끼리의 연산
위치와 벡터 구분하기
space = (집합)
연산이 정의되는 집합 = 열린집합

스칼라=양, 벡터=방향+크기, 
cross product 회전시킬때 필요한힘?
벡터는 위치가 없음

위치와 위치를 빼면 벡터(덧셈은x)
>> affine space

homo~ coordinate 가 이 연산을 가능하게 함

transformaion(변환)
선형변환 vs 비선형변환
선형변환은 모두 행렬로 표현 가능
비선형을 미분하여 선형으로 표현가능
선형과 선형을 합성하면 리니어
=행렬과 행렬을 곱하면 행렬

이동
회전 스케일링 모두 행렬의 곱셈으로 표현가능함
그래서 굳이 이동도 곰셈으로 표현하는것

190328

메트릭스는 벡터의 모음
4차원 메트릭스는 4차원 벡터 4개
각각의 벡터는 3차원 벡터일수도 3차원 위치일수도

선형변환(이동, 회전, 확대축소)은 행렬로 표현 가능

한가지 연산만 하기 위해 이동할때 곱셈을 함


회전

cos -sin
sin  cos

첫번째컬럼 = 1,0 이 어디로가야되는지 알려줌
두번째컬럼 = 0,1 이 어디로 가야되는지
세로로 읽어야 함

2차원회전 = 3x3행렬
세타만큼 돌아갔을때의 축. x축은 방향이기때문에 컬럼의 세번째 숫자 0
두번째 컬럼도 마찬가지
세번째 컬럼 0,0,1(t)  = 0,0이라는 지점
			좌표계라는것은 두개의 축과 원점으로 이루어져 있음

그래서 이 3x3행렬은 회전된 2차원 좌표계를 의미
4차원 행렬도 마찬가지 의미

3차원은 벡터(방향,힘)도 회전시킴

벡터는 확대축소에 영향 받음


모델 transformation
각각 모델의 이동 회전 확대축소
(확대축소행렬) * (회전행렬) * (이동행렬) = 모델 transformation

원점기준이 아닌걸 확대축소, 회전 하려면 원점으로 이동 후 변환

instancing
수많은 잔디를 표현할때
수많은 버텍스들이 필요한데 이것을 다 그리지 않고
잔디 인스턴스 하나 만들어서 확대, 축소, 이동, 회전 등 하여 여러번 그림


지금까진 모델변환
view 변환은? (카메라에 대해서)
스케일링은 보통 안씀. 이동, 회전만 조합

frame
포인트 표현할때 마지막에 1을 넣는 이유 = 원점이 필요함  
벡터 표현할때 0을 넣는 이유 어디서 출발하는지 필요가 없음


190402

view transformation
카메라 좌표계 : 로테이션, 이동은 하는데 확대축소는 잘 안함

x1 곱하기 첫번째 컬럼
x2 곱하기 두번째 컬럼
x3 곱하기 세번째 컬럼
1 곱하기 네번째 컬럼

x축방향으로 x1만큼
y축 방향으로 x2만큼
z 방향으로 x3 만큼
원점에서부터

ortho normal frame == 직각이고 단위벡터인 좌표계

완전 디폴트 카메라 좌표계는 world 좌표계와 같음
1 0 0 0
0 1 0 0
0 0 1 0
0 0 0 1

여기서 카메라를 이동 >> 로테이션 후 이동

V = TR
이걸 역행렬 해야하는 상황이 생기는데 4x4 역행렬 구하기 어려움

로테이션행렬은 역행렬 구하기가 쉬움
	>> transpose 하면 됨
이동의 역행렬은?
	>> dx, dy, dz에 -1 붙임


버텍스 프로세서

왜 역행렬을 곱해야하나

좌표계와 좌표값 분리하기
좌표값은 좌표계 없이는 의미없는 정보


Model view 메트릭스
카메라 기준으로 그려야하기 때문에 카메라에 inverse 취해서 곱해줌

좌표계를 카메라 좌표계로 바꿔준 것
 	>> 모델 뷰 메트릭스

perspective 이든 ortho 이든 
정형화 되어있는 view == canonical == 변 길이 2인 정육면체?
로 변환
 	>> 리니어하므로 프로젝션 메트릭스

190404

버텍스프로세서가 저기까지 해줌

뷰포트는 버텍스프로세스 이후에
뷰포트 = 실제 너의 인화지 크기가 얼마인지?
	실제 화면에 늘려서, 줄여서 그리는것
게임화면에 미니맵도 있듯이

아직 그리지는 않아서 매우 크게 그린다고해서 화질이 깨지지는 않음

깊이가 2에서 1로 바꾼다는데 먼소리지

옛날 게임은 4:3이던 aspect ratio를 16:9로 바꿔줌

마지막 순간에는 스크린에서 축 방향이 아예 바뀜
좌측 상단이 0,0

정리하면
버텍스를 심는것 >> 모델 좌표계에서
모델 메트릭스를 곱하는 순간 월드좌표계
강의자료는 좌표계가 0,0,0에서 떨어져 있는데 붙어있어야 함
V를 곱하는 순간 월드좌표계로 변함
모델 뷰 메트릭스 곱하면 카메라 좌표계에서 물체를 바라보는 형태가 됨
지금까지는 카메라의 extrinsic 파라미터를 적용한 것

intrinsic == 프로젝션 메트릭스
perspective >> 클리핑스페이스
이렇게 하는 이유는 interactive하게 만들기 위해
스크린에서의 정보를 obj로 보내는 방법은 양 변에 역행렬들 곱해주기

실습
실행파일을 실행시키는 명령어에 &를 붙이면 백그라운드에서 실행됨?
h와 l을 누르면 왼쪽 오른쪽
j는 아래 k는 위로 이동

callback == 이벤트리스너의 C버전
특정이벤트가 불렸을때 불리는 함수
두번 움직이는 이유는 눌렸다가 떼는 두가지 이벤트가 발생해서

자바의 이벤트 리스너는 상속 받은다음에 사용하는데
C구조에서는 등록까지 해야함. 메인에서

  glfwSetKeyCallback(window, key_callback);
를 통하는데 어딨는지 함수 포인터로 알려줌 >> 함수이름으로

gpu는 건드리지 않았는데 화면이 바뀌는 이유
set_transform 함수에서
모델 메트릭스는 translate 함수로 구성됨 >> 메인메모리에 있는 행렬
gpu로 넘기는법?
render object 함수에서
pvm에 저장해서 uniformMatrix함수로 어딘가에 보냄
카메라는 기본적으로 canonical view 볼륨임
좌우위아래 1씩


